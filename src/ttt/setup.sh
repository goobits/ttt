#!/bin/bash
# ============================================================================
# AUTO-GENERATED FILE - DO NOT EDIT
# Generated by Goobits CLI Framework (https://github.com/goobits/goobits-cli)
# To regenerate this file, run: goobits build
# ============================================================================
#
# Generic Setup Framework for Python Projects
# This script provides a robust, performant setup system with extensive validation

set -e

# Enable performance optimizations
export LC_ALL=C
export LANG=C

# Prevent Python bytecode generation during development
export PYTHONDONTWRITEBYTECODE=1

# Core configuration
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Since this is a generated script, PROJECT_DIR is where the script lives
readonly PROJECT_DIR="$SCRIPT_DIR"
readonly CACHE_DIR="$HOME/.cache/setup-framework"
readonly CACHE_FILE="$CACHE_DIR/system-info.cache"
readonly CACHE_TTL=3600  # 3600 in seconds

# Colors for output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly NC='\033[0m' # No Color

# Tree view components
readonly TREE_BRANCH="├─"
readonly TREE_LAST="└─"
readonly TREE_PIPE="│ "
readonly TREE_SPACE="  "

# Tree view state
TREE_MODE="${TREE_MODE:-true}"
TREE_DEPTH=0
TREE_PREFIX=""
TREE_BUFFER=""

# Progress tracking
TOTAL_STEPS=5
CURRENT_STEP=0
START_TIME=$(date +%s)

# Check if terminal supports colors
if [[ -t 1 ]] && [[ "$(tput colors 2>/dev/null)" -ge 8 ]]; then
    USE_COLOR=true
else
    USE_COLOR=false
fi

# Project-specific configuration
readonly PACKAGE_NAME="goobits-ttt"
readonly COMMAND_NAME="ttt"
readonly DISPLAY_NAME="TTT - Terminal Tools for Thoughts"
readonly DESCRIPTION="A powerful AI assistant for your terminal"
readonly PYPI_NAME="goobits-ttt"
readonly DEVELOPMENT_PATH="."
readonly REQUIRED_VERSION="3.8"
readonly MAXIMUM_VERSION="3.13"
readonly CHECK_API_KEYS="False"
readonly CHECK_DISK_SPACE="True"
readonly REQUIRED_MB="100"
readonly SHELL_INTEGRATION="False"
readonly SHELL_ALIAS="ttt"

# Dependencies (legacy format for backward compatibility)
readonly REQUIRED_DEPS=()
readonly OPTIONAL_DEPS=()

# Enhanced dependency data (JSON format for complex dependencies)
# Note: Using installation.extras structure instead

# Tree view helper functions
tree_start() {
    local title="$1"
    echo "$DISPLAY_NAME Setup $(get_version)"
    echo "$TREE_LAST $title"
    TREE_DEPTH=1
    TREE_PREFIX="   "
}

tree_node() {
    local status="$1"
    local message="$2"
    local progress="$3"
    local is_last="${4:-false}"

    local status_icon
    case "$status" in
        "success") status_icon="✓" ;;
        "warning") status_icon="⚠" ;;
        "error") status_icon="✗" ;;
        "info") status_icon="•" ;;
        "progress") status_icon="⟳" ;;
        "waiting") status_icon="⋯" ;;
        *) status_icon="" ;;
    esac

    local progress_text=""
    if [[ -n "$progress" ]]; then
        progress_text=" ($progress%)"
    fi

    if [[ "$is_last" == "true" ]]; then
        echo "${TREE_PREFIX}$TREE_LAST $status_icon $message$progress_text"
    else
        echo "${TREE_PREFIX}$TREE_BRANCH $status_icon $message$progress_text"
    fi
}

tree_sub_node() {
    local status="$1"
    local message="$2"
    local is_last="${3:-false}"

    local status_icon
    case "$status" in
        "success") status_icon="✓" ;;
        "warning") status_icon="⚠" ;;
        "error") status_icon="✗" ;;
        "info") status_icon="•" ;;
        "progress") status_icon="⟳" ;;
        "waiting") status_icon="⋯" ;;
        *) status_icon="" ;;
    esac

    local sub_prefix="${TREE_PREFIX}$TREE_PIPE "
    if [[ "$is_last" == "true" ]]; then
        echo "${sub_prefix}$TREE_LAST $status_icon $message"
    else
        echo "${sub_prefix}$TREE_BRANCH $status_icon $message"
    fi
}

tree_final_node() {
    local status="$1"
    local message="$2"
    
    local status_icon
    case "$status" in
        "success") status_icon="✓" ;;
        "warning") status_icon="⚠" ;;
        "error") status_icon="✗" ;;
        "info") status_icon="•" ;;
        *) status_icon="" ;;
    esac
    
    echo "${TREE_PREFIX}$TREE_LAST $status_icon $message"
}

get_version() {
    # Return the version from pyproject.toml (hardcoded during build)
    echo "v1.0.1"
}

get_elapsed_time() {
    local current_time=$(date +%s)
    local elapsed=$((current_time - START_TIME))
    printf "[%02d:%02d]" $((elapsed / 60)) $((elapsed % 60))
}

update_progress() {
    CURRENT_STEP=$((CURRENT_STEP + 1))
    local progress=$((CURRENT_STEP * 100 / TOTAL_STEPS))
    echo "$progress"
}

# Platform detection
detect_platform() {
    if [[ -f /etc/os-release ]]; then
        source /etc/os-release
        case "$ID" in
            ubuntu) echo "ubuntu" ;;
            debian) echo "debian" ;;
            centos|rhel) echo "centos" ;;
            fedora) echo "fedora" ;;
            *) echo "linux" ;;
        esac
    elif [[ "$OSTYPE" == "darwin"* ]]; then
        echo "macos"
    elif [[ "$OSTYPE" == "cygwin" ]] || [[ "$OSTYPE" == "msys" ]]; then
        echo "windows"
    else
        echo "unknown"
    fi
}

# Validate system package using various methods
validate_system_package() {
    local dep_name="$1"
    local dep_type="$2"
    local platform_package="$3"
    local check_method="$4"
    local check_args="$5"
    
    # If it's a command type, use command -v
    if [[ "$dep_type" == "command" ]]; then
        command -v "$dep_name" >/dev/null 2>&1
        return $?
    fi
    
    # For system packages, try different detection methods
    case "$check_method" in
        "pkg_config")
            if command -v pkg-config >/dev/null 2>&1; then
                if [[ -n "$check_args" ]]; then
                    eval "pkg-config $check_args" >/dev/null 2>&1
                    return $?
                else
                    pkg-config --exists "$dep_name" >/dev/null 2>&1
                    return $?
                fi
            fi
            ;;
        "dpkg_query")
            if command -v dpkg >/dev/null 2>&1; then
                dpkg -l | grep -q "^ii.*$platform_package" 2>/dev/null
                return $?
            fi
            ;;
        "rpm_query")
            if command -v rpm >/dev/null 2>&1; then
                rpm -q "$platform_package" >/dev/null 2>&1
                return $?
            fi
            ;;
        "brew_list")
            if command -v brew >/dev/null 2>&1; then
                brew list "$platform_package" >/dev/null 2>&1
                return $?
            fi
            ;;
        "file_exists")
            if [[ -n "$check_args" ]]; then
                for file_path in $check_args; do
                    [[ -f "$file_path" ]] && return 0
                done
            fi
            return 1
            ;;
    esac
    
    # Fallback: try platform-specific detection
    local current_platform=$(detect_platform)
    case "$current_platform" in
        "ubuntu"|"debian")
            if command -v dpkg >/dev/null 2>&1; then
                dpkg -l | grep -q "^ii.*$platform_package" 2>/dev/null
                return $?
            fi
            ;;
        "centos"|"fedora")
            if command -v rpm >/dev/null 2>&1; then
                rpm -q "$platform_package" >/dev/null 2>&1
                return $?
            fi
            ;;
        "macos")
            if command -v brew >/dev/null 2>&1; then
                brew list "$platform_package" >/dev/null 2>&1
                return $?
            fi
            ;;
    esac
    
    return 1
}

# Generate installation instruction for missing package
generate_install_instruction() {
    local dep_name="$1"
    local platform_package="$2"
    local install_instructions="$3"
    
    local current_platform=$(detect_platform)
    
    # Check if custom install instructions are provided
    if [[ -n "$install_instructions" ]]; then
        # Parse JSON-like install instructions (simplified)
        local instruction=$(echo "$install_instructions" | grep -o "\"$current_platform\":[^,}]*" | cut -d: -f2- | tr -d '"')
        if [[ -n "$instruction" ]]; then
            echo "$instruction"
            return
        fi
    fi
    
    # Generate default instructions based on platform
    case "$current_platform" in
        "ubuntu"|"debian")
            echo "sudo apt update && sudo apt install $platform_package"
            ;;
        "centos")
            echo "sudo yum install $platform_package"
            ;;
        "fedora")
            echo "sudo dnf install $platform_package"
            ;;
        "macos")
            echo "brew install $platform_package"
            ;;
        *)
            echo "Install $dep_name ($platform_package) using your system package manager"
            ;;
    esac
}

# Logging functions (original + tree mode support)
log_info() {
    if [[ "$TREE_MODE" == "true" ]]; then
        return  # Tree mode handles its own output
    fi
    if [[ "$USE_COLOR" == "true" ]]; then
        echo -e "${BLUE}[INFO]${NC} $*" >&2
    else
        echo "[INFO] $*" >&2
    fi
}

log_success() {
    if [[ "$TREE_MODE" == "true" ]]; then
        return  # Tree mode handles its own output
    fi
    if [[ "$USE_COLOR" == "true" ]]; then
        echo -e "${GREEN}[SUCCESS]${NC} $*" >&2
    else
        echo "[SUCCESS] $*" >&2
    fi
}

log_warning() {
    if [[ "$TREE_MODE" == "true" ]]; then
        return  # Tree mode handles its own output
    fi
    if [[ "$USE_COLOR" == "true" ]]; then
        echo -e "${YELLOW}[WARNING]${NC} $*" >&2
    else
        echo "[WARNING] $*" >&2
    fi
}

log_error() {
    if [[ "$TREE_MODE" == "true" ]]; then
        return  # Tree mode handles its own output
    fi
    if [[ "$USE_COLOR" == "true" ]]; then
        echo -e "${RED}[ERROR]${NC} $*" >&2
    else
        echo "[ERROR] $*" >&2
    fi
}

# Spinner for long-running operations
show_spinner() {
    local pid=$1
    local delay=0.15
    local spinstr='⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏'
    local fallback_spinstr='|/-\'

    # Use Unicode spinner if terminal supports it, otherwise ASCII
    if [[ "$USE_COLOR" == "true" ]]; then
        local current_spinstr="$spinstr"
    else
        local current_spinstr="$fallback_spinstr"
    fi

    echo -n "   "
    while ps -p "$pid" > /dev/null 2>&1; do
        local temp=${current_spinstr#?}
        printf "\b\b\b %c " "${current_spinstr:0:1}"
        current_spinstr=$temp${current_spinstr%"$temp"}
        sleep $delay
    done
    printf "\b\b\b   \n"
}

# System information cache
get_cached_system_info() {
    if [[ -f "$CACHE_FILE" ]]; then
        local cache_age=$(($(date +%s) - $(stat -c %Y "$CACHE_FILE" 2>/dev/null || stat -f %m "$CACHE_FILE" 2>/dev/null || echo 0)))
        if [[ $cache_age -lt $CACHE_TTL ]]; then
            source "$CACHE_FILE"
            return 0
        fi
    fi
    return 1
}

cache_system_info() {
    mkdir -p "$CACHE_DIR"
    cat > "$CACHE_FILE" << EOF
SYSTEM_OS="$SYSTEM_OS"
SYSTEM_ARCH="$SYSTEM_ARCH"
PYTHON_VERSION="$PYTHON_VERSION"
PYTHON_PATH="$PYTHON_PATH"
PIPX_AVAILABLE="$PIPX_AVAILABLE"
PIPX_PATH="$PIPX_PATH"
EOF
}

detect_system() {
    if ! get_cached_system_info; then
        if [[ "$TREE_MODE" != "true" ]]; then
            log_info "Detecting system configuration..."
        fi
        
        # Detect OS
        if [[ "$OSTYPE" == "linux-gnu"* ]]; then
            SYSTEM_OS="linux"
        elif [[ "$OSTYPE" == "darwin"* ]]; then
            SYSTEM_OS="macos"
        elif [[ "$OSTYPE" == "cygwin" ]] || [[ "$OSTYPE" == "msys" ]]; then
            SYSTEM_OS="windows"
        else
            SYSTEM_OS="unknown"
        fi
        
        # Detect architecture
        SYSTEM_ARCH="$(uname -m)"
        
        # Detect Python
        if command -v python3 >/dev/null 2>&1; then
            PYTHON_PATH="$(command -v python3)"
            PYTHON_VERSION="$(python3 --version 2>&1 | cut -d' ' -f2)"
        elif command -v python >/dev/null 2>&1; then
            PYTHON_PATH="$(command -v python)"
            PYTHON_VERSION="$(python --version 2>&1 | cut -d' ' -f2)"
        else
            PYTHON_PATH=""
            PYTHON_VERSION=""
        fi
        
        # Detect pipx
        if command -v pipx >/dev/null 2>&1; then
            PIPX_AVAILABLE="true"
            PIPX_PATH="$(command -v pipx)"
        else
            PIPX_AVAILABLE="false"
            PIPX_PATH=""
        fi
        
        cache_system_info
    fi
}

# Version comparison function
version_compare() {
    local version1=$1
    local version2=$2
    
    # Convert versions to arrays
    IFS='.' read -ra v1_parts <<< "$(echo "$version1" | sed 's/[^0-9.]*//g')"
    IFS='.' read -ra v2_parts <<< "$(echo "$version2" | sed 's/[^0-9.]*//g')"
    
    # Pad arrays to same length
    local max_parts=3
    for ((i=${#v1_parts[@]}; i<$max_parts; i++)); do
        v1_parts[i]=0
    done
    for ((i=${#v2_parts[@]}; i<$max_parts; i++)); do
        v2_parts[i]=0
    done
    
    # Compare each part
    for ((i=0; i<$max_parts; i++)); do
        # Force base 10 to avoid octal interpretation
        local p1=$((10#${v1_parts[i]:-0}))
        local p2=$((10#${v2_parts[i]:-0}))
        
        if [[ $p1 -lt $p2 ]]; then
            return 1  # version1 < version2
        elif [[ $p1 -gt $p2 ]]; then
            return 2  # version1 > version2
        fi
    done
    
    return 0  # version1 == version2
}

validate_python() {
    if [[ -z "$PYTHON_PATH" ]]; then
        log_error "Python is not installed or not found in PATH"
        log_error "Please install Python $REQUIRED_VERSION or later"
        return 1
    fi
    
    if [[ "$TREE_MODE" != "true" ]]; then
        log_info "Found Python $PYTHON_VERSION at $PYTHON_PATH"
    fi
    
    # Check minimum version
    version_compare "$PYTHON_VERSION" "$REQUIRED_VERSION"
    case $? in
        1)  # Current version is less than required
            log_error "Python $PYTHON_VERSION is installed, but $REQUIRED_VERSION or later is required"
            return 1
            ;;
        0|2)  # Current version is equal or greater than required
            if [[ "$TREE_MODE" != "true" ]]; then
                log_success "Python version requirement satisfied"
            fi
            ;;
    esac
    
    # Check maximum version if specified
    if [[ -n "$MAXIMUM_VERSION" ]]; then
        version_compare "$PYTHON_VERSION" "$MAXIMUM_VERSION"
        case $? in
            2)  # Current version is greater than maximum
                log_error "Python $PYTHON_VERSION is installed, but maximum supported version is $MAXIMUM_VERSION"
                return 1
                ;;
            0|1)  # Current version is equal or less than maximum
                log_success "Python maximum version requirement satisfied"
                ;;
        esac
    fi
    
    return 0
}

# Tree mode versions of validation functions
validate_python_tree() {
    if [[ -z "$PYTHON_PATH" ]]; then
        tree_sub_node "error" "Python not found in PATH" "true"
        return 1
    fi
    
    # Check minimum version
    version_compare "$PYTHON_VERSION" "$REQUIRED_VERSION"
    case $? in
        1)  # Current version is less than required
            tree_sub_node "error" "Python $PYTHON_VERSION < $REQUIRED_VERSION (required)" "true"
            return 1
            ;;
        0|2)  # Current version is equal or greater than required
            return 0
            ;;
    esac
}

validate_dependencies_tree() {
    local missing_deps=()
    local optional_missing=()
    local install_instructions=()
    
    # Enhanced dependency validation using JSON data
    if command -v python3 >/dev/null 2>&1; then
        # Parse and validate required dependencies
        local required_result=$(python3 -c "
import json
import sys
try:
    required_deps = json.loads('$REQUIRED_DEPS_JSON')
    current_platform = '$SYSTEM_OS'
    
    missing = []
    instructions = []
    
    for dep in required_deps:
        if isinstance(dep, str):
            dep = {'name': dep, 'type': 'command'}
        
        dep_name = dep['name']
        dep_type = dep.get('type', 'command')
        
        # Get platform-specific package name
        platform_package = dep.get(current_platform, dep_name)
        check_method = dep.get('check_method', '')
        check_args = ' '.join(dep.get('check_args', []))
        
        # For now, we'll do basic validation in shell
        print(f'{dep_name}|{dep_type}|{platform_package}|{check_method}|{check_args}')
except Exception as e:
    # Fallback to simple validation
    pass
")
        
        # Process each dependency
        while IFS='|' read -r dep_name dep_type platform_package check_method check_args; do
            if [[ -n "$dep_name" ]]; then
                if ! validate_system_package "$dep_name" "$dep_type" "$platform_package" "$check_method" "$check_args"; then
                    missing_deps+=("$dep_name")
                    local instruction=$(generate_install_instruction "$dep_name" "$platform_package" "")
                    install_instructions+=("$instruction")
                fi
            fi
        done <<< "$required_result"
    else
        # Fallback to legacy validation
        for dep in "${REQUIRED_DEPS[@]}"; do
            if ! command -v "$dep" >/dev/null 2>&1; then
                missing_deps+=("$dep")
            fi
        done
    fi
    
    # Similar process for optional dependencies (simplified)
    for dep in "${OPTIONAL_DEPS[@]}"; do
        if ! command -v "$dep" >/dev/null 2>&1; then
            optional_missing+=("$dep")
        fi
    done
    
    # Display results
    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        tree_sub_node "error" "Missing required: ${missing_deps[*]}"
        if [[ ${#install_instructions[@]} -gt 0 ]]; then
            tree_sub_node "info" "Install with: ${install_instructions[0]}" "true"
        fi
        return 1
    fi
    
    if [[ ${#optional_missing[@]} -gt 0 ]]; then
        tree_sub_node "warning" "${optional_missing[*]} (optional)" "true"
    fi
    
    return 0
}

# Package Management Functions
# ============================
validate_pipx() {
    if [[ "$PIPX_AVAILABLE" != "true" ]]; then
        log_warning "pipx is not installed. Installing pipx is recommended for isolated Python applications."
        log_info "You can install pipx with: python3 -m pip install --user pipx"
        log_info "Or on macOS with Homebrew: brew install pipx"
        return 1
    fi
    
    log_success "pipx is available at $PIPX_PATH"
    return 0
}

# Installation functions
install_package() {
    local install_dev="$1"
    
    if [[ "$PIPX_AVAILABLE" == "true" ]]; then
        install_with_pipx "$install_dev"
    else
        install_with_pip "$install_dev"
    fi
}

install_with_pipx() {
    local install_dev="$1"

    if [[ "$install_dev" == "true" ]]; then
        tree_node "info" "Installing in development mode" "$(update_progress)"
        tree_sub_node "info" "Using pipx for isolated environment"

        
        # Install system dependencies BEFORE Python packages
        install_system_dependencies
        

        
        (cd "$PROJECT_DIR" && pipx install --editable "$DEVELOPMENT_PATH[local]" --force) &
        
        local install_pid=$!

        tree_sub_node "progress" "Creating development environment..."
        show_spinner $install_pid
        wait $install_pid
        local exit_code=$?

        if [[ $exit_code -eq 0 ]]; then
            tree_sub_node "success" "Development installation completed" "" "true"
            
            show_dev_success_message
        else
            tree_sub_node "error" "Development installation failed" "" "true"
            return 1
        fi
    else
        tree_node "info" "Installing from PyPI" "$(update_progress)"
        tree_sub_node "info" "Using pipx for isolated environment"

        
        # Install system dependencies BEFORE Python packages
        install_system_dependencies
        

        
        pipx install "$PYPI_NAME[local]" --force &
        
        local install_pid=$!

        tree_sub_node "progress" "Downloading and installing package..."
        show_spinner $install_pid
        wait $install_pid
        local exit_code=$?

        if [[ $exit_code -eq 0 ]]; then
            tree_sub_node "success" "Installation completed" "" "true"
            
            show_install_success_message
        else
            tree_sub_node "error" "Installation failed" "" "true"
            return 1
        fi
    fi
}

install_with_pip() {
    local install_dev="$1"

    tree_sub_node "warning" "Using pip instead of pipx (not recommended)"

    
    # Install system dependencies BEFORE Python packages
    install_system_dependencies
    

    if [[ "$install_dev" == "true" ]]; then
        tree_sub_node "progress" "Installing in development mode with pip..."
        
        (cd "$PROJECT_DIR" && python3 -m pip install --editable "$DEVELOPMENT_PATH[local]" --user) &
        
        show_spinner $!
        wait $!
        local exit_code=$?

        if [[ $exit_code -eq 0 ]]; then
            tree_sub_node "success" "Development installation completed" "true"
            
            show_dev_success_message
        else
            tree_sub_node "error" "Development installation failed" "true"
            return 1
        fi
    else
        tree_sub_node "progress" "Installing from PyPI with pip..."
        
        python3 -m pip install "$PYPI_NAME[local]" --user &
        
        show_spinner $!
        wait $!
        local exit_code=$?

        if [[ $exit_code -eq 0 ]]; then
            tree_sub_node "success" "Installation completed" "true"
            
            show_install_success_message
        else
            tree_sub_node "error" "Installation failed" "true"
            return 1
        fi
    fi
}

upgrade_package() {
    # Don't add another tree node - we're under the main "Upgrade Process" from tree_start

    if [[ "$PIPX_AVAILABLE" == "true" ]]; then
        if pipx list | grep -q "$PACKAGE_NAME"; then
            tree_sub_node "info" "Using pipx for upgrade"
            tree_sub_node "progress" "Upgrading with pipx..."

            # Use script to fully capture all pipx output including TTY writes
            if command -v script >/dev/null 2>&1; then
                script -q -c "pipx upgrade $PACKAGE_NAME" /dev/null >/dev/null 2>&1 &
            else
                # Fallback: direct capture
                pipx upgrade "$PACKAGE_NAME" >/dev/null 2>&1 </dev/null &
            fi
            show_spinner $!
            wait $!
            local exit_code=$?
        else
            tree_sub_node "error" "Package not found in pipx" "true"
            return 1
        fi
    else
        tree_sub_node "info" "Using pip for upgrade"
        tree_sub_node "progress" "Upgrading with pip..."

        # Capture pip output to prevent it from breaking tree structure
        
        python3 -m pip install --upgrade "$PYPI_NAME[local]" --user >/dev/null 2>&1 &
        
        show_spinner $!
        wait $!
        local exit_code=$?
    fi

    if [[ $exit_code -eq 0 ]]; then
        tree_sub_node "success" "Upgrade completed" "true"
        # Success message suppressed - tree already shows completion
    else
        tree_sub_node "error" "Upgrade failed" "true"
        return 1
    fi
}

uninstall_package() {
    if [[ "$PIPX_AVAILABLE" == "true" ]]; then
        log_info "Uninstalling $DISPLAY_NAME with pipx..."
        pipx uninstall "$PYPI_NAME" &
        show_spinner $!
        wait $!
    else
        log_info "Uninstalling $DISPLAY_NAME with pip..."
        python3 -m pip uninstall "$PYPI_NAME" -y &
        show_spinner $!
        wait $!
    fi
    
    if [[ $? -eq 0 ]]; then
        log_success "Uninstall completed!"
        show_uninstall_success_message
    else
        log_error "Uninstall failed"
        return 1
    fi
}

# Message display functions
show_install_success_message() {
    echo
    echo "TTT has been installed successfully!
You can now use 'ttt' or 't' (if shell integration is enabled) from your terminal.

Quick start:
  ttt "Hello, how can I help you today?"
  ttt status
  ttt models
"
    echo
}

show_dev_success_message() {
    echo
    echo "TTT has been installed in development mode!
✅ Your local changes will be reflected immediately - no reinstalling needed!

Development workflow:
  - Edit code in src/ttt/ directory
  - Test immediately with: ttt --stream "test"
  - Run tests with: ./test.sh
  - Format code with: ruff format src/ttt/
  - Check types with: mypy src/ttt/

💡 No need to run ./setup.sh upgrade after code changes!
"
    echo
}

show_upgrade_success_message() {
    echo
    echo "TTT has been upgraded successfully!
Check out the latest features with: ttt --version
"
    echo
}

show_uninstall_success_message() {
    echo
    echo "TTT has been uninstalled.
Thank you for using TTT!
"
    echo
}


# System dependencies installation (before Python packages)
install_system_dependencies() {
    if command -v apt-get >/dev/null 2>&1; then
        # Check which packages are missing
        local missing_packages=()
        
        
        if ! dpkg -l | grep -q "^ii.*git" 2>/dev/null; then
            missing_packages+=("git")
        else
            tree_sub_node "success" "✓ Already installed: git"
        fi
        
        if ! dpkg -l | grep -q "^ii.*pipx" 2>/dev/null; then
            missing_packages+=("pipx")
        else
            tree_sub_node "success" "✓ Already installed: pipx"
        fi
        
        if ! dpkg -l | grep -q "^ii.*curl" 2>/dev/null; then
            missing_packages+=("curl")
        else
            tree_sub_node "success" "✓ Already installed: curl"
        fi
        
        
        # Only prompt for sudo if there are missing packages
        if [[ ${#missing_packages[@]} -gt 0 ]]; then
            tree_sub_node "info" "Installing system packages: ${missing_packages[*]} (requires sudo)..."
            
            # Update package list first if we're installing anything
            if ! sudo apt-get update >/dev/null 2>&1; then
                tree_sub_node "warning" "Failed to update package list"
            fi
            
            # Install each missing package
            for pkg in "${missing_packages[@]}"; do
                if sudo apt-get install -y "$pkg" >/dev/null 2>&1; then
                    tree_sub_node "success" "Installed apt package: $pkg"
                else
                    tree_sub_node "warning" "Failed to install apt package: $pkg"
                fi
            done
        else
            tree_sub_node "success" "All system packages already installed"
        fi
    else
        tree_sub_node "info" "apt-get not found - manual installation required for: git, pipx, curl"
    fi
}




# Shell integration
setup_shell_integration() {
    if [[ "$SHELL_INTEGRATION" != "true" ]]; then
        return 0
    fi
    
    log_info "Setting up shell integration..."
    
    # Add alias to shell configuration files
    local shell_configs=("$HOME/.bashrc" "$HOME/.zshrc" "$HOME/.bash_profile" "$HOME/.profile")
    local alias_line="alias $SHELL_ALIAS='$COMMAND_NAME'"
    
    for config in "${shell_configs[@]}"; do
        if [[ -f "$config" ]] && ! grep -q "alias $SHELL_ALIAS=" "$config"; then
            echo "$alias_line" >> "$config"
            log_info "Added alias to $config"
        fi
    done
    
    log_success "Shell integration configured"
}

validate_disk_space() {
    if [[ "$CHECK_DISK_SPACE" != "true" ]]; then
        return 0
    fi
    
    local available_mb
    if command -v df >/dev/null 2>&1; then
        available_mb=$(df "$PROJECT_DIR" | awk 'NR==2 {print int($4/1024)}')
        
        if [[ $available_mb -lt $REQUIRED_MB ]]; then
            log_error "Insufficient disk space. Required: ${REQUIRED_MB}MB, Available: ${available_mb}MB"
            return 1
        fi
        
        log_success "Disk space check passed (${available_mb}MB available)"
    else
        log_warning "Cannot check disk space (df command not available)"
    fi
    
    return 0
}

validate_dependencies() {
    local missing_deps=()
    local optional_missing=()
    local install_instructions=()
    
    # Enhanced dependency validation using JSON data
    if command -v python3 >/dev/null 2>&1; then
        # Parse and validate required dependencies
        local required_result=$(python3 -c "
import json
import sys
try:
    required_deps = json.loads('$REQUIRED_DEPS_JSON')
    current_platform = '$SYSTEM_OS'
    
    missing = []
    instructions = []
    
    for dep in required_deps:
        if isinstance(dep, str):
            dep = {'name': dep, 'type': 'command'}
        
        dep_name = dep['name']
        dep_type = dep.get('type', 'command')
        
        # Get platform-specific package name
        platform_package = dep.get(current_platform, dep_name)
        check_method = dep.get('check_method', '')
        check_args = ' '.join(dep.get('check_args', []))
        
        # For now, we'll do basic validation in shell
        print(f'{dep_name}|{dep_type}|{platform_package}|{check_method}|{check_args}')
except Exception as e:
    # Fallback to simple validation
    pass
")
        
        # Process each dependency
        while IFS='|' read -r dep_name dep_type platform_package check_method check_args; do
            if [[ -n "$dep_name" ]]; then
                if ! validate_system_package "$dep_name" "$dep_type" "$platform_package" "$check_method" "$check_args"; then
                    missing_deps+=("$dep_name")
                    local instruction=$(generate_install_instruction "$dep_name" "$platform_package" "")
                    install_instructions+=("$instruction")
                fi
            fi
        done <<< "$required_result"
    else
        # Fallback to legacy validation
        for dep in "${REQUIRED_DEPS[@]}"; do
            if ! command -v "$dep" >/dev/null 2>&1; then
                missing_deps+=("$dep")
            fi
        done
    fi
    
    # Similar process for optional dependencies (simplified)
    for dep in "${OPTIONAL_DEPS[@]}"; do
        if ! command -v "$dep" >/dev/null 2>&1; then
            optional_missing+=("$dep")
        fi
    done
    
    # Display results
    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        log_error "Missing required dependencies: ${missing_deps[*]}"
        if [[ ${#install_instructions[@]} -gt 0 ]]; then
            log_info "To install missing dependencies:"
            for instruction in "${install_instructions[@]}"; do
                log_info "  $instruction"
            done
        fi
        return 1
    fi
    
    if [[ ${#optional_missing[@]} -gt 0 ]]; then
        log_warning "Missing optional dependencies: ${optional_missing[*]}"
        log_warning "Some features may not be available"
    fi
    
    if [[ "$TREE_MODE" != "true" ]]; then
        log_success "Dependency check completed"
    fi
    return 0
}






# Help and usage
show_help() {
    cat << EOF
$DISPLAY_NAME Setup Framework

DESCRIPTION:
    $DESCRIPTION

USAGE:
    $0 [COMMAND] [OPTIONS]

COMMANDS:
    install                 Install $DISPLAY_NAME from PyPI
    install --dev          Install $DISPLAY_NAME in development mode
    upgrade                Upgrade $DISPLAY_NAME to the latest version
    uninstall              Uninstall $DISPLAY_NAME
    validate               Validate system requirements without installing
    help                   Show this help message

OPTIONS:
    --force                Skip confirmation prompts
    --no-deps              Skip dependency checks
    --no-cache             Skip system information caching
    --simple               Use simple log output instead of tree view

EXAMPLES:
    $0 install             # Install from PyPI
    $0 install --dev       # Development installation
    $0 upgrade             # Upgrade to latest version
    $0 validate            # Check requirements

For more information, visit the project documentation.
EOF
}

# Main execution
main() {
    local command="${1:-install}"
    local force_flag="false"
    local no_deps="false"
    local no_cache="false"
    local install_dev="false"
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            install|upgrade|uninstall|validate|help)
                command="$1"
                ;;
            --dev)
                install_dev="true"
                ;;
            --force)
                force_flag="true"
                ;;
            --no-deps)
                no_deps="true"
                ;;
            --no-cache)
                no_cache="true"
                ;;
            --simple)
                TREE_MODE="false"
                ;;
            *)
                log_error "Unknown option: $1"
                show_help
                exit 1
                ;;
        esac
        shift
    done
    
    # Handle help command
    if [[ "$command" == "help" ]]; then
        show_help
        exit 0
    fi
    
    # Header
    if [[ "$TREE_MODE" == "true" ]]; then
        tree_start "${command^} Process"
    else
        echo
        log_info "Starting $DISPLAY_NAME setup..."
        echo
    fi
    
    # System detection
    if [[ "$no_cache" != "true" ]]; then
        detect_system
    fi
    
    # Validation
    if [[ "$command" != "uninstall" ]]; then
        tree_node "info" "System Check" "$(update_progress)"

        # Python validation
        if validate_python_tree; then
            tree_sub_node "success" "Python $PYTHON_VERSION"
        else
            exit 1
        fi

        # Dependencies validation
        if [[ "$no_deps" != "true" ]]; then
            if validate_dependencies_tree; then
                : # Already handled in function
            else
                exit 1
            fi
        fi

        # pipx validation for install
        if [[ "$command" == "install" ]]; then
            if [[ "$PIPX_AVAILABLE" == "true" ]]; then
                tree_sub_node "success" "pipx available" "true"
            else
                tree_sub_node "warning" "pipx not available - using pip" "true"
            fi
        fi
    fi
    
    # Execute command
    case "$command" in
        install)
            tree_node "info" "Installation Process"
            if install_package "$install_dev"; then
                CURRENT_STEP=$((TOTAL_STEPS - 1))
                tree_node "info" "Post-install configuration" "$(update_progress)" "true"
                setup_shell_integration
                tree_final_node "success" "Installation Complete - $(get_elapsed_time)"
                echo "        └─ Try: $COMMAND_NAME --version"
            else
                tree_final_node "error" "Installation Failed - $(get_elapsed_time)"
                exit 1
            fi
            ;;
        upgrade)
            tree_node "info" "Package Upgrade" "$(update_progress)"
            if upgrade_package; then
                CURRENT_STEP=$((TOTAL_STEPS - 1))
                tree_final_node "success" "Upgrade Complete - $(get_elapsed_time)"
                echo "        └─ Try: $COMMAND_NAME --version"
            else
                tree_final_node "error" "Upgrade Failed - $(get_elapsed_time)"
                exit 1
            fi
            ;;
        uninstall)
            if [[ "$force_flag" != "true" ]]; then
                echo -n "Are you sure you want to uninstall $DISPLAY_NAME? [y/N]: "
                read -r response
                if [[ ! "$response" =~ ^[Yy]$ ]]; then
                    echo "Uninstall cancelled"
                    exit 0
                fi
            fi
            tree_node "info" "Uninstall Process"
            if uninstall_package; then
                tree_final_node "success" "Uninstall Complete - $(get_elapsed_time)"
            else
                tree_final_node "error" "Uninstall Failed - $(get_elapsed_time)"
                exit 1
            fi
            ;;
        validate)
            log_success "All system requirements validated successfully!"
            ;;
        *)
            log_error "Unknown command: $command"
            show_help
            exit 1
            ;;
    esac
    
    if [[ "$TREE_MODE" != "true" ]]; then
        echo
        log_success "$DISPLAY_NAME setup completed!"
    fi
}

# Run main function with all arguments
main "$@"